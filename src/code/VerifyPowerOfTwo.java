package code;

public class VerifyPowerOfTwo {

    /*
     * n & -n 获得二进制表示中的最后一位 1
     * 1
     * 如 n = 8 = (1000)v2
     * 补码为 1000
     *
     * -n = -8 = (1000 0000 0000 0000 0000 0000 0000 1000)v2
     * 反码为 (0111 1111 1111 1111 1111 1111 1111 0111)v2
     * 补码为 (0111 1111 1111 1111 1111 1111 1111 1000)v2
     *
     * 所以 n & -n = (1000)v2 = n
     *
     * 如 n = 10 = (1010)v2
     * -n = -10 = (1000 0000 0000 0000 0000 0000 0000 1010)v2
     * 反码为 (0111 1111 1111 1111 1111 1111 1111 0101)v2
     * 补码为 (0111 1111 1111 1111 1111 1111 1111 0110)v2
     *
     * 所以 n & -n = (0010)v2
     *
     * 证明
     * 假设x>0 且第m位 为1 且后面皆为0
     * 则 x = (0...1 000...000)v2 1后面m-1个0
     * -x = (1...1 000...000)v2 1后面m-1个0
     * 反码为(0rrr0 111...111)v2 0后面m-1个1  rrr表示与... 相反
     * 补码为(0rrr1 000...000)v2 1后面m-1个0
     *
     * 则x&-x = (0rrr1 000...000)v2 & (0...1 000...000)v2
     *        = (00001 000...000)v2 最终为获取到最后一位为1的数
     *
     * 利用此性质可以判断数n是否为2的幂
     * (n & -n) == n
     * 常用于哈希散列算法中  如 netty给eventLoopGroup 中的线程分配任务就是使用的此方式
     * */
    public boolean verifyPowerOfTwo(int n) {
        return (n & -n) == n;
    }
}
